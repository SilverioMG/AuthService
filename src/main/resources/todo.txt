	
	V-Los métodos de 'UserQueryService' y 'RoleQueryService' que lancen Exceptions con mensajes localizados cuando no se encuentra la entidad en la B.D. Igual es mejor añadir un campo a las 'ExceptionWithMessageLocalized' y
	 'RuntimeExceptionWithMessageLocalized' que indique el código Http de la respuesta (HttpStatus) y utilizarlo directamente en el 'ExceptionHandlerComponent'.
	V-Modificar el 'ConverterUserToUserDto' para que por defecto el método 'convert()' no mapee el campo 'password' y modificar el método 'convertWithoutPassword()' para que sea 'convertWithPassword()'.
	 
//TODO...
	-Añadir un Controller y Servicio para que los usuario se puedan autenticar (recuperar Token JWT). Hacer en la authorizacion (filter) que los datos se recuperen del User se recuperen del JWT en vez de la B.D.
	-Añadir seguridad en Controllers.
	-Quitar CORS.
	-Añadir JPA Auditing en las entidades. Ver por el proyecto 'SharingCodersServer' de Gitlab.
	-Hacer tests utilizando otra B.D. de prueba. Un test de carga sobre las consultas paginadas de Usuarios que hace otra consulta para los Roles ver si tarda mucho con muchos Usuarios.
	-Probar el método 'AbstractQueryService.validatePageRequest()'.
	-Probar el método 'AbstractQueryService.composeNullablePredicates()' que modifiqué el switch para utilizar una expresión lambda.
	-Que en la clase 'ValidatorEntity' se pueda lanzar una 'ValidationException' personalizada, es decir, para cada entidad (User, Role...) se debe declarar una Exception que herede de 'ValidationException'
	 y que se declare la nueva Exception en el 'Component' que hereda de 'ValidationException' (UserValidationComponent).
	-Probar el BundleValidationException.
	-Actualizar versión de SpringBoot para utilizar la última versión de 'LogBack'.
	-Añadir configuración para CORS.
	-Probar Query paginada de 'User'. Usar Lógica AND y OR para los nombres de 'Roles'.
	 Ver donde se están utilizando estos métodos e intercambiarlos para que por defecto no se mapee el password (más seguridad).
	-Añadir Swagger y Actuator.
	-Añadir funcionalidad para enviar email al usuario una vez que se registra y active su cuenta (usar una tabla de tokens para los enlaces de activación que se envían en el email).
	-Los usuarios que no estén activados no pueden loguearse ni obtener JWT Tokens. Ver que servidor utilizo para envíar los emails (mailchimp utilizando la capa gratuita o JavaMail con una cuenta de google).
	 Esta funcionalidad no se va a implementar, ya que este proyecto será una librería para otros proyectos. Lo que hay que hacer es que desde el proyecto que consuma esta librería añada la funcionalidad de
	 enviar emails si es necesario.
	-JpaAuditing.
	-Spring Security con User creado por defecto que sea Admin y al que posteriormente se le cambie el password.
	-Añadir Módulos de Java 11.
	-Hacer una libreria .jar con los paquetes que son reutilizables para otros Servicios Web. Sino quiero utilizar un nexus puedo compilarlos en local y que se guarden en la carpeta .m2 con mvn install.
	 O se puede utilizar el servicio que ofrece GitHub como repositorio de artefactos (paquetes).
	-Añadir entornos de ejecutación (dev y prod).
	-Modfiicar query 'IUserRepository.findAllWithRoles()' para que no haga la paginación en memoria. Hacer una query paginada solo de Usuarios y luego con otra consulta recuperar sus roles.
	
	De este proyecto hacer 2 librerías. La primera que sea 'net.atopecode.backend-utils' con todo el código que se puede reutilizar en cualquier proyecto SpringBoot como las validaciones,
	la normalización, AbstractQueryService... Y otra librería que a su vez utilice 'net.atopecode.backend-utils' con todo el código de gestión de Usuarios, tanto la parte de B.D. como la Autenticación y
	la Autorización. Así esta última librería se puede importar en cualquier proyecto con acceso a una B.D. y tener gestión de Usuarios con token JWT automáticamente.
	Acordarse de seperar de los archivos .properties del 'locale' las propiedades que son de la librería 'atopecode.backend-utils' y las que son propias del proyecto en un properties dentro de 'resources' del proyecto.
	Y comprobar que se leen los mensajes de la librería desde el proyecto principal. Si en la librería el archivo de mensajes es 'messages.properties' y en el proyecto se llama igual ver si coge el mensaje
	de la librería cuando no existe en el proyecto principal. Sino igual hay que cambiar el nombre de los archivos .properties de la librería y hacer un wrapper del 'LocaleService' en el que se indique el nombre
	de todos los archivos donde buscar mensajes y sino encuentra el mensaje en un archivo que pase al siguiente (esa lógica está implementada en el proyecto 'Javalicho' y 'JavalichoTest').